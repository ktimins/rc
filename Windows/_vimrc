
let homedir="C:\\Users\\TiminsKy"
let $home = "C:\\Users\\Timinsky"

" Startup
let s:running_windows = has("win16") || has ("win32") || has ("win64")
let s:colorful_term = (&term =~ "xterm") || (&term =~ "screen")

" Basics
nmap , <leader>
set nocompatible
set background=dark
set fenc=utf-8
set cpoptions=aABceFsmq
 "             |||||||||
 "             ||||||||+-- When joining lines, leave the cursor between joined lines
 "             |||||||+-- When a new match is created (showmatch) pause for .5
 "             ||||||+-- Set buffer options when entering the buffer
 "             |||||+-- :write command updates current file name automatically add <CR> to the last line when using :@r
 "             |||+-- Searching continues at the end of the match at the cursor position
 "             ||+-- A backslash has no special meaning in mappings
 "             |+-- :write updates alternative file name
 "             +-- :read updates alternative file name
set history=9999
set timeoutlen=500
set formatoptions+=n
set formatlistpat=^\\s*\\(\\d\\\|[-*]\\)\\+[\\]:.)}\\t\ ]\\s*
set viminfo+=!
set nomore
set ttyfast
set ttyscroll=5
set number
set norelativenumber
map <F3> ggVGg?

set noerrorbells
set novisualbell
set t_vb=

set t_ut=

filetype plugin indent on
syntax on
set backspace=indent,eol,start
runtime! ftdetect*.vim
set backup
"set backupdir=$home/_backup
"set directory=$home/_backup
set undofile

if s:running_windows
	set backupdir=$home\\_backup
	set undodir=$home\\_undo
	set directory=$home\\_temp
endif
set noswapfile

set fileformats=unix,dos
set wildmenu
set wildignore=*.pdf,*.pyo,*.pyc,*.zip,*.so,*.swp,*.dll,*.o,*.DS_Store,*.obj,*.bak,*.exe,*.pyc,*.jpg,*.gif,*.png,*.a " ignore these
 if s:running_windows
     set wildignore+=*\\.git\\*,*\\.hg\\*,*\\.svn\\*,*\\bin\\*,*\\pkg\\*
 else
     set wildignore+=*/.git/*,*/.hg/*,*/.svn/*,*/bin/*,*/pkg/*
 endif
 set wildmode=list:longest " turn on wild mode huge list
 set viewoptions=folds,options,cursor,unix,slash " Windows/Linux compatibility
" set nojoinspaces " Prevents inserting two spaces after punctuation on a join (J)
 set splitbelow " new splits are down
 set splitright " new vsplits are to the right
 set switchbuf=useopen " jump to first open window with buffer

 set sidescroll=5 " If you hit edge, jump 5
 set scrolljump=5 " If you hit bottom or top, jump 5
 set laststatus=2
 set statusline=%F%m%r%h%w[%L][%{&ff}]%y[%p%%][%04l,%04v]
 "              | | | | |  |   |      |  |     |    |
 "              | | | | |  |   |      |  |     |    +-- current column
 "              | | | | |  |   |      |  |     +-- current line
 "              | | | | |  |   |      |  +-- current % into file
 "              | | | | |  |   |      +-- current syntax in square brackets
 "              | | | | |  |   +-- current fileformat
 "              | | | | |  |
 "              | | | | |  +-- number of lines
 "              | | | | +-- preview flag in square brackets
 "              | | | +-- help flag in square brackets
 "              | | +-- readonly flag in square brackets
 "              | +-- rodified flag in square brackets
 "              +-- full path to file in the buffer

" Text Formatting/Layout
" set completeopt=menuone " don't use a pop up menu for completions
set diffopt=filler,iwhite " filler and whitespace
set expandtab " no real tabs please!
set formatoptions=rq " Automatically insert comment leader on return, and let gq format comments
set ignorecase " case insensitive by default
set infercase " case inferred by default
set smartcase " if there are caps, go case-sensitive
set nowrap " do not wrap line
set textwidth=0 " No autowrapping
set shiftround " when at 3 spaces, and I hit > ... go to 4, not 5
set shiftwidth=3 " auto-indent amount when using cindent, >>, << and stuff like that
set softtabstop=3 " when hitting tab or backspace, how many spaces should a tab be (see expandtab)
set tabstop=3 " real tabs should be 8, and they will show with set list on
set ai
set cindent
set cinkeys-=0#
set indentkeys-=0#
set hlsearch
nmap <leader>h :nohl<CR>
set incsearch
set ai
set cindent
autocmd BufNewFile,BufRead *.txt set nocindent
 
" Folding
set foldenable " Turn on folding
set foldmethod=indent " Fold on the marker
"set foldmarker={,} " use simple markers
set foldlevel=100 " Don't autofold anything (but I can still fold manually)
set foldnestmax=100 " I only like to fold outer functions
set foldopen=block,hor,mark,percent,quickfix,tag " what movements open folds
nnoremap <space> za

 
set undolevels=1000 " persistent undo
set undoreload=10000 " to undo forced reload with :e! 

if has("gui_running")
     " Basics
     "set guifont=Consolas:h9:cANSI " My favorite font
     colorscheme fu
     set guioptions+=ceb
     "               |||
     "               ||+-- use horizontal scroll bar
     "               |+-- use simple dialogs rather than pop-ups
     "               +-- use GUI tabs, not console style tabs
     set mousehide " hide the mouse cursor when typing
     nnoremap <C-F1> :if &go=~#'m'<Bar>set go-=m<Bar>else<Bar>set go+=m<Bar>endif<CR>
     nnoremap <C-F2> :if &go=~#'T'<Bar>set go-=T<Bar>else<Bar>set go+=T<Bar>endif<CR>
     nnoremap <C-F3> :if &go=~#'r'<Bar>set go-=r<Bar>else<Bar>set go+=r<Bar>endif<CR>
else
	colorscheme elflord
endif

if has("autocmd")
   filetype plugin indent on
   set shellslash
   set grepprg=grep\ -nH\ $*
   "let g:tex_flavor='latex'

   augroup vimrcEx
      au!
      autocmd FileType txt setlocal textwidth=130
      autocmd BufReadPost *
               \ if line("'\"") >= 1 && line("'\"") <= line("$") |
               \  exe "normal! g`\"" |
               \ endif
   augroup END
else
   set autoindent
endif

if !exists(":DiffOrig")
   command DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis
            \ | wincmd p | diffthis
endif

if has('langmap') && exists('+langnoremap')
   set langnoremap
endif

:let g:ps1_nofold_blocks = 1

"set shell=powershell
"set shellcmdflag=-command


"" XML formatter
"function! DoFormatXML() range
"	" Save the file type
"	let l:origft = &ft
"
"	" Clean the file type
"	set ft=
"
"	" Add fake initial tag (so we can process multiple top-level elements)
"	exe ":let l:beforeFirstLine=" . a:firstline . "-1"
"	if l:beforeFirstLine < 0
"		let l:beforeFirstLine=0
"	endif
"	exe a:lastline . "put ='</PrettyXML>'"
"	exe l:beforeFirstLine . "put ='<PrettyXML>'"
"	exe ":let l:newLastLine=" . a:lastline . "+2"
"	if l:newLastLine > line('$')
"		let l:newLastLine=line('$')
"	endif
"
"	" Remove XML header
"	exe ":" . a:firstline . "," . a:lastline . "s/<\?xml\\_.*\?>\\_s*//e"
"
"	" Recalculate last line of the edited code
"	let l:newLastLine=search('</PrettyXML>')
"
"	" Execute external formatter
"	exe ":silent " . a:firstline . "," . l:newLastLine . "!xmllint --noblanks --format --recover -"
"
"	" Recalculate first and last lines of the edited code
"	let l:newFirstLine=search('<PrettyXML>')
"	let l:newLastLine=search('</PrettyXML>')
"	
"	" Get inner range
"	let l:innerFirstLine=l:newFirstLine+1
"	let l:innerLastLine=l:newLastLine-1
"
"	" Remove extra unnecessary indentation
"	exe ":silent " . l:innerFirstLine . "," . l:innerLastLine "s/^  //e"
"
"	" Remove fake tag
"	exe l:newLastLine . "d"
"	exe l:newFirstLine . "d"
"
"	" Put the cursor at the first line of the edited code
"	exe ":" . l:newFirstLine
"
"	" Restore the file type
"	exe "set ft=" . l:origft
"endfunction
"command! -range=% FormatXML <line1>,<line2>call DoFormatXML()
"
"nmap <silent> <leader>x :%FormatXML<CR>
"vmap <silent> <leader>x :FormatXML<CR>

nnoremap <silent> <leader>x gg=G
vnoremap <silent> <leader>x gg=G

nnoremap <silent> <leader>ll :%s/ at/ at\r   /g<CR>

nnoremap <F5> :silent !"C:\Program Files (x86)\Google\Chrome\Application\chrome.exe" --new-window %:p<CR>
nmap <leader>mdb :silent !"C:\Program Files (x86)\Microsoft Office\Office14\MSACCESS.EXE" %:p<CR>
nmap <leader>doc :silent !"C:\Program Files (x86)\Microsoft Office\Office14\WINWORD.EXE" %:p<CR>

function! ColorSchemeSwap()
   if g:colors_name ==? "fu"
      colorscheme habiLight
   else
      colorscheme fu
   endif
endfunction

function! RelativeNumberSwap()
   if (&relativenumber) 
      set norelativenumber
   else
      set relativenumber
   endif
endfunction

function! NumberSwap()
   if (&number) 
      set nonumber
   else
      set number
   endif
endfunction

function! SyntaxSwap()
   if exists("g:syntax_on")
      syntax off
   else
      syntax on
   endif
endfunction

noremap <silent> <F6> :call ColorSchemeSwap()<CR>
vnoremap <silent> <F6> :call ColorSchemeSwap()<CR>

noremap <silent> <F7> :call SyntaxSwap()<CR>
vnoremap <silent> <F7> :call SyntaxSwap()<CR>

noremap <silent> <F8> :call RelativeNumberSwap()<CR>
vnoremap <silent> <F8> :call RelativeNumberSwap()<CR>

noremap <silent> <F9> :call NumberSwap()<CR>
vnoremap <silent> <F9> :call NumberSwap()<CR>

noremap  <buffer> <silent> k gk
noremap  <buffer> <silent> j gj
"noremap  <buffer> <silent> 0 g0
"noremap  <buffer> <silent> $ g$


:let g:indent_guides_start_level = 2


function! ViewHtmlText(url)
  if !empty(a:url)
    new
    setlocal buftype=nofile bufhidden=hide noswapfile
    execute 'r !elinks ' . a:url . ' -dump -dump-width ' . winwidth(0)
    1d
  endif
endfunction
" Save and view text for current html file.
nnoremap <Leader>ht :update<Bar>call ViewHtmlText(expand('%:p'))<CR>
" View text for visually selected url.
"vnoremap <Leader>h y:call ViewHtmlText(@@)<CR>
" View text for URL from clipboard.
" On Linux, use @* for current selection or @+ for text in clipboard.
"nnoremap <Leader>h :call ViewHtmlText(@+)<CR>

"""""""""""""
"   JSON    "
"""""""""""""
au! BufRead, BufNewFile *.json set filetype=json

augroup json_autocmd 
  autocmd! 
  autocmd FileType json set autoindent 
  autocmd FileType json set formatoptions=tcq2l 
  autocmd FileType json set shiftwidth=3 
  autocmd FileType json set softtabstop=3 tabstop=8 
  autocmd FileType json set expandtab 
  autocmd FileType json set foldmethod=syntax 
  autocmd BufNewFile,BufRead *.json nnoremap f== :%!python -m json.tool<CR>
augroup END

"""""""""""""
"    XML    "
"""""""""""""
au! BufRead, BufNewFile *.sln set filetype=sln
let g:xml_syntax_folding=1
au! BufRead, BufNewFile *.xml set filetype=xml
autocmd BufNewFile,BufRead *.xml nnoremap f== :%!xmllint --format %<CR>

au FileType xml exe ":silent %!xmllint --format -"
augroup xml
   autocmd!
   autocmd FileType xml set cindent
   autocmd FileType xml set formatoptions=tcq2l
   autocmd FileType xml set shiftwidth=3 
   autocmd FileType xml set softtabstop=3 tabstop=8 
   autocmd FileType xml set expandtab 
   autocmd FileType xml set foldmethod=indent 
   au FileType xml exe ":silent %!xmllint --format --valid --encode utf-8 -"
   au FileType xml exe ":%s/ //g"
   au FileType xml noremap <buffer> <silent> <C-F5> :%!xmllint --format - 
augroup END

au! BufRead, BufNewFile *.xaml set filetype=xaml
augroup xaml
   autocmd!
   autocmd FileType xaml set cindent
"   autocmd FileType xaml set formatoptions=tcq2l
   autocmd FileType xaml set shiftwidth=3 
   autocmd FileType xaml set softtabstop=3 tabstop=8 
   autocmd FileType xaml set expandtab 
   autocmd FileType xaml set foldmethod=indent 
augroup END

au FileType ps1 exe ":silent ! ctags -R %"
au! BufRead, BufNewFile *.ps1 set filetype=ps1
augroup ps1
   autocmd!
   autocmd FileType ps1 set cindent
   autocmd FileType ps1 set formatoptions=tcq2l
   autocmd FileType ps1 set shiftwidth=3 
   autocmd FileType ps1 set softtabstop=3 tabstop=8 
   autocmd FileType ps1 set expandtab 
   autocmd FileType ps1 set foldmethod=indent 
augroup END

au FileType vb  exe ":silent ! ctags -R %"
au FileType cls exe ":silent ! ctags -R %"
au FileType bas exe ":silent ! ctags -R %"
au FileType xml exe ":silent ! ctags -R %"

"""""""""""""
" Vim-Plug  "
"""""""""""""
call plug#begin('~/.vim/plugged')
   
   Plug 'nathanaelkane/vim-indent-guides'
   Plug 'godlygeek/tabular'
   Plug 'plasticboy/vim-markdown'
   Plug 'scrooloose/nerdtree', { 'on' : 'NERDTreeToggle' }
   Plug 'mbbill/undotree'
   Plug 'PProvost/vim-ps1'
   Plug 'majutsushi/tagbar'
   Plug 'chrisbra/csv.vim'
   Plug 'godlygeek/tabular'

call plug#end()


""""""""""
" TagBar "
""""""""""
noremap <silent> <F10> :TagbarToggle<CR>

let g:tagbar_ctags_bin = 'C:\Users\TiminsKY\bin\ctags\ctags.exe'
let g:tagbar_type_psm1 = {
   \ 'ctagstype' : 'powershell',
   \ 'kinds'     : [
      \ 'f:function',
      \ 'h:functionCall',
      \ 'i:filter',
      \ 'a:alias',
      \ 'r:region'
   \ ]
\ }
let g:tagbar_type_ps1 = {
   \ 'ctagstype' : 'powershell',
   \ 'kinds'     : [
      \ 'f:function',
      \ 'h:functionCall',
      \ 'i:filter',
      \ 'a:alias',
      \ 'r:region'
   \ ]
\ }
let g:tagbar_type_vb = {
   \ 'ctagstype' : 'vb',
   \ 'kinds'     : [
      \ 's:subroutine',
      \ 'f:function',
      \ 'v:variable',
      \ 'c:const',
      \ 'n:name',
      \ 'e:enum',
      \ 't:type',
      \ 'l:label'
   \ ]   
\ }
let g:tagbar_type_cls = {
   \ 'ctagstype' : 'vb',
   \ 'kinds'     : [
      \ 's:subroutine',
      \ 'f:function',
      \ 'v:variable',
      \ 'c:const',
      \ 'n:name',
      \ 'e:enum',
      \ 't:type',
      \ 'l:label'
   \ ]   
\ }
let g:tagbar_type_bas = {
   \ 'ctagstype' : 'vb',
   \ 'kinds'     : [
      \ 's:subroutine',
      \ 'f:function',
      \ 'v:variable',
      \ 'c:const',
      \ 'n:name',
      \ 'e:enum',
      \ 't:type',
      \ 'l:label'
   \ ]   
\ }
let g:tagbar_type_xml = {
   \ 'ctagstype'  : 'XML',
   \ 'kinds'      : [
      \ 'd:definitions'
   \ ]
\ }

"""""""""""""""""""""
" Vim Indent Guides "
"""""""""""""""""""""
let g:indent_guides_enable_on_vim_startup = 1
let g:indent_guides_start_level = 2
let g:indent_guides_indent_levels = 30
let g:indent_guides_guide_size = 1
let g:indent_guides_exclude_filetypes = ['help', 'nerdtree']

"""""""""""""
" Nerd Tree "
"""""""""""""
autocmd StdinReadPre * let s:std_in=1
noremap <C-n> :NERDTreeToggle<CR>
noremap <C-z> :UndotreeToggle<CR>

"""""""""""""
"  Colemak  "  
"""""""""""""
noremap! e f
noremap! r p
noremap! t g
noremap! y j
noremap! u l
noremap! i u
noremap! o y
noremap! p ;
noremap! s r
noremap! d s
noremap! f t
noremap! g d
noremap! j n
noremap! k e
noremap! l i
noremap! ; o
noremap! n k
noremap! E F
noremap! R P
noremap! T G
noremap! Y J
noremap! U L
noremap! I U
noremap! O Y
noremap! P :
noremap! S R
noremap! D S
noremap! F T
noremap! G D
noremap! J N
noremap! K E
noremap! L I
noremap! : O
noremap! N K


